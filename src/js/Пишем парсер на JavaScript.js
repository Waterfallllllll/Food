"use strict";

// Парсер - это часть программы которая принимает в себя какие-то данные и на выходе выдает их модифицированными.

window.addEventListener("DOMContentLoaded", () => {
    const body = document.querySelector("body");
    let textNodes = [];


    function recursy(element) {
        element.childNodes.forEach(node => { // Обращаемся ко всем потомкам body и получаем массив из потомков
            // if (element.childNodes.length > 1) { // Если вдруг элемент который был передан в данную функцию имеет больше чем 1 потомка, то мы будем запускать эту функцию заново, только уже с той нодой которая нам придёт из перебора.
            //     recursy(node);
            // }
            // if (node.nodeName === "#text") { // Если нода текстовая, то просто заканчиваем функцию.
            //     return;
            // } else { // Теперь мы получили только теги, без текстовых нод.
            //     console.log(node);
            //     recursy(node);
            // }
            if (node.nodeName.match(/^H\d/)) { // Добавляем немного конкретики и реальных действий. Тут мы отделяем все наши дивы и прочее от обычных заголовков. Свойство nodeName нам приходит в виде строки, а если это строка, то мы с легкостью тут можем применить регулярное выражение. В метод match мы помещаем регулярное выражение. Он возвращает нам либо true либо false, в соответствии с тем, что если регулярное выражение сработало, то нам вернется true, в противном случае false. ^ - начало строки. H - все заголовки у нас пишутся с большой буквы в прочем как и теги тоже. d - говорим, что у нас может быть какое-то число. У нас же есть много заголовков H(h1,h2,h3...).
                const obj = {
                    header: node.nodeName, // Мы хотим знать из какого именно заголовка пришёл этот текст. 1 порядка, 2 порядка итд.
                    content: node.textContent 
                };
                textNodes.push(obj); // Сохраняем весь контент который мы отфильтровали в массив. У нас получается массив из объектов, который мы отправляем на сервер.
            } else { // Теперь мы получили только теги, без текстовых нод.
                recursy(node);
            }
        });
    }

    recursy(body);

    fetch("http://localhost:3000/requests", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(textNodes) //Это то, что мы отправляем на сервер
    })
        .then(response => response.json()) //Чтобы увидеть, что наш запрос успешно ушел и нам сервер что-то ответил. Мы используем цепочку промисов.
        .then(json => console.log(json));
    
    // Мы получаем поверхностные узлы, но нам нужны узлы которые находятся внутри внутри и внутри. Мы бы хотели пройти всю страничку и показать список всех узлов которые вообще существуют на страничке. Поэтому тут нам понадобится приём который называется рекурсия. Мы будем перебирать все узлы до тех пор, пока не натолкнемся на какой-то текстовый, то есть на конечный узел, если конечно такой будет.

    // Задача: хотим получить все теги заголовков которые есть на странице, их содержимое и после этого отправить информацию к себе на сервер.
});